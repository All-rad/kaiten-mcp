# Feature Specification: Инициализация структуры проекта (Hello endpoint + UI)

**Feature Branch**: `001-init-project-structure`  
**Created**: 2026-02-01  
**Status**: Draft  
**Input**: User description: "Реализуй спецификацию функциональности на основе обновлённой конституции. Я хочу инициализировать структуру проекта.
- базовый backend проект с hello {name} эндпоинтом
- базовый UI проект (`ui/`) с одной страницей - вводом имени и кнопкой чтобы через запрос поздароваться с бэк частью
- инструментами и инструкциями по сборке UI и backend по отдельности
- инструментами и инструкциями по сборке UI и backend в единое самодостаточное приложение"

## Clarifications

### Session 2026-02-01

- Q: Какой формат и метод запроса для эндпоинта приветствия? → A: `GET /hello/{name}` — возвращает 200 и JSON `{ "message": "Hello, <name>" }`.
  - Если сегмент пути `name` отсутствует (например, `GET /hello/`) — сервер возвращает **400 Bad Request** и JSON `{ "error": "name missing" }`.
  - Если `name` присутствует, но невалидно (например, слишком длинное) — сервер возвращает **400 Bad Request** и JSON `{ "error": "<описание>" }`.

- Q: Какой код ответа при отсутствии сегмента пути `name` (например, `GET /hello/`)? → A: 400 Bad Request.

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Greet via UI (Priority: P1)

Пользователь (или разработчик при демонстрации) открывает UI (интерфейс), вводит имя и нажимает кнопку «Поздороваться». UI отправляет запрос к бэкенду, получает ответ с приветствием и отображает его.

**Why this priority**: Это основной пользовательский поток – демонстрация связи фронтенда и бэкенда и подтверждение работоспособности минимальной фичи.

**Independent Test**: Запустить бэкенд и фронтенд локально, ввести имя и убедиться, что отображается ожидаемое приветствие.

**Acceptance Scenarios**:

1. **Given** фронтенд и бэкенд запущены, **When** пользователь вводит "Анна" и нажимает кнопку, **Then** фронтенд отображает "Hello, Анна" (или эквивалентный ответ, специфицированный ниже).
2. **Given** бэкенд недоступен, **When** пользователь нажимает кнопку, **Then** фронтенд показывает человекопонятную ошибку об отсутствии соединения.

---

### User Story 2 - Backend: standalone endpoint (Priority: P2)

Разработчик может запустить бэкенд отдельно и выполнить запрос к эндпоинту приветствия для проверки его работы.

**Why this priority**: Позволяет тестировать и развивать бэкенд независимо от фронтенда.

**Independent Test**: Запустить бэкенд и выполнить HTTP-запрос (curl/postman) к `/hello/{name}` и проверить статус и тело ответа.

**Acceptance Scenarios**:

1. **Given** бэкенд запущен, **When** выполнен GET `/hello/Иван`, **Then** ответ 200 и тело содержит понятное приветствие (например, `{ "message": "Hello, Иван" }`).

   Примеры (curl):

   - Успешный запрос:

     ```bash
     curl -i "http://localhost:8080/hello/Иван"
     ```

     Ожидаемый ответ:

     ```http
     HTTP/1.1 200 OK
     Content-Type: application/json

     { "message": "Hello, Иван" }
     ```

   - Отсутствует имя (пустой URL):

     ```bash
     curl -i "http://localhost:8080/hello/"
     ```

     Ожидаемый ответ:

     ```http
     HTTP/1.1 400 Bad Request
     Content-Type: application/json

     { "error": "name missing" }
     ```

     Примечание: Путь `GET /hello/{name}` требует наличия сегмента `name`. Запрос к `/hello/` без сегмента `name` возвращает 400 Bad Request с JSON `{ "error": "name missing" }`.

   - Слишком длинное имя (>256 символов):

     ```bash
     # пример генерации длинного имени (bash)
     long=$(printf 'a%.0s' {1..300})
     curl -i "http://localhost:8080/hello/$long"
     ```

     Ожидаемый ответ:

     ```http
     HTTP/1.1 400 Bad Request
     Content-Type: application/json

     { "error": "name too long" }
     ```

     Примечание: При длине `name` более 256 символов сервер возвращает 400 и соответствующее сообщение об ошибке.

2. **Given** запрос не содержит имени (пустое значение), **When** выполнен запрос, **Then** бэкенд возвращает 400 Bad Request (см. выше: `GET /hello/` возвращает 400).

---

### User Story 3 - UI: standalone build & dev (Priority: P2)

UI можно собрать и запускать отдельно в режиме разработки и в режиме продакшн-ассета.

**Why this priority**: Отдельная сборка упрощает разработку и CI проверку UI.

**Independent Test**: Выполнить шаги из `ui/README.md` чтобы запустить локальный dev-сервер и подтвердить тот же пользовательский поток (P1).

---

### User Story 4 - Unified build / single runnable app (Priority: P3)

Разработчик может выполнить единый набор команд, который соберёт фронтенд и бэкенд и предоставит самодостаточное приложение для локального запуска или для доставки.

**Why this priority**: Упрощает демонстрации и поставку приложения, но не обязателен для минимального MVP.

**Independent Test**: Выполнить команду/скрипт описанный в корневом `README.md` и подтвердить, что приложение запускается и P1 сценарий работает.

**Acceptance Scenarios**:

1. **Given** чистая копия репозитория, **When** выполнены шаги по объединённой сборке, **Then** приложение начинает работать локально с одним шагом и P1 работает.

---

### Edge Cases

- Запрос с пустым именем: бэкенд возвращает 400 Bad Request с объяснением (см. FR-002).
- Очень длинное имя (больше 256 символов): бэкенд возвращает 400 или усечённое приветствие — поведение задокументировать.
- Имя с не-ASCII символами: система поддерживает UTF-8 и корректно отображает значение.
- Временный недоступ бэкенда: фронтенд показывает понятное сообщение об ошибке и не падает.

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: Бэкенд MUST предоставить HTTP-эндпоинт `GET /hello/{name}` который возвращает 200 и JSON `{ "message": "Hello, <name>" }`. Если имя отсутствует или невалидно, вернуть 400 и JSON `{ "error": "<описание>" }`.
- **FR-002**: Бэкенд MUST валидировать входные данные: если имя отсутствует или невалидно, вернуть 400 с объяснением ошибки.
- **FR-003**: UI MUST предоставить одну страницу (размещается в директории `ui/`) с полем ввода имени и кнопкой, которая вызывает бэкенд и отображает ответ/ошибку. **Все пользовательские UI-тексты и сообщения ДОЛЖНЫ быть на русском языке** (требование Конституции).
- **FR-004**: Репозиторий MUST включать отдельные директории `backend/` и `ui/` с README и скриптами для сборки/запуска в режиме разработки и для продакшн-ассетов.
- **FR-005**: Репозиторий MUST включать корневой скрипт `build.sh`, который при запуске выполняет объединённую сборку: собирает фронтенд и бэкенд, создаёт директорию `out/` с подпапкой `kaiten-mcp/`, содержащую статические файлы фронтенда, JAR-файлы бэкенда, конфигурационные файлы, включает JRE и платформенно-специфичные скрипты запуска/остановки для Linux и Windows. Скрипт также создаёт ZIP-архив `out/kaiten-mcp.zip`. Поставка должна позволять запускать приложение двойным кликом (через UI ОС) и/или командой в терминале; скрипт старта должен запускать Java-сервер в фоновом режиме, выводить в терминал ссылку на UI (если возможно) и по возможности открыть страницу в браузере.
- **FR-006**: Каждый проект (backend/ui) MUST иметь минимальный набор автоматизированных тестов: unit-тесты (JUnit/Jest) **и** scripted smoke-tests (bash/curl) демонстрирующие P1 и P2 сценарии. **Smoke-tests MUST NOT инициализировать Spring Context или другие тяжёлые application contexts**; они должны выполняться как внешние HTTP-запросы.
- **FR-007**: Репозиторий MUST содержать инструкции по локальной разработке, по сборке для продакшна и по запуску интеграционных проверок.

### Key Entities *(include if feature involves data)*

- **Greeting**: Структура ответа от бэкенда. Пример: `{ "message": "Hello, <name>" }`.
- **Build artifact**: Произведённые файлы/пакеты фронтенда и бэкенда, готовые к развёртыванию.

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: Разработчик может собрать и запустить бэкенд локально, следуя документации, за менее чем 2 минуты на стандартной дев-машине.
- **SC-002**: Разработчик может собрать и запустить фронтенд локально, следуя документации, за менее чем 2 минуты.
- **SC-003**: `build.sh` выполняется и завершает объединённую сборку за менее чем 5 минут на стандартной дев-машине, создаёт `out/kaiten-mcp/` и ZIP-архив `out/kaiten-mcp.zip`.
- **SC-004**: Пакет `out/kaiten-mcp.zip` содержит JRE, скрипты запуска/остановки для Linux и Windows, backend JAR(ы), статические файлы UI и файлы конфигурации.
- **SC-005**: Запуск скрипта старта из распакованной поставки запускает Java-сервер в фоновом режиме, печатает в терминал ссылку на локальный UI и (по возможности) открывает страницу в браузере; пользователь может также запустить UI двойным кликом.
- **SC-006**: Минимальный набор автоматизированных тестов (смоук-тесты) выполняется и проходит со статусом успеха в CI для обеих частей.
- **SC-007**: README содержит пошаговые команды для всех сценариев: dev backend, dev UI, prod build UI, prod build backend, unified build/run, и инструкции по запуску распакованной поставки.
